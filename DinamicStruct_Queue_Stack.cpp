#include "Stdafx.h"

using namespace std;
//***************************| 2 Variant |*************************


void BaseLevel()
{

	/*1.Создать очередь из вещественных чисел. Определить количество положительных значений элементов очереди.
	Организовать просмотр данных очереди.
	*/

	cout << "\nBase level task\n";
	queue* q;
	float a;
	system("cls");
	q = (queue*)malloc(sizeof(queue));
	init(q);
//	print(q);
	int counter = 0;
	cout << "\nЭлементы хранящиеся в очереди: \n";
	for (int i = 0; i < 8; i++) {
		//printf("Введите элемент очереди %d: ",i+1);
		//scanf("%f", &a);
		a = (-5.0 + (rand() % 100)/9.0);
		printf("%2.1f ", a);
		(a < 0) ? counter : ++counter;
		insert(q, a);
	}
	cout << "\nЭлементы выведеные из очереди: \n";
	print(q);
	cout << "\nCount positive digit " << counter<<"\n";
	while (q->frnt <= q->rear) {
		a = removex(q);
		printf("\nЭлемент %2.1f вышел из очереди\n", a);
		print(q);

	}
}


//СТРУКТУРА БУДЕТ ЭЛЕМЕНТОМ СПИСКА

struct Node                           //или просто Звено списка
{
	float x;                           //инфо данные структуры
	Node* Next;                      //Указатель не следующее звено
};

//КЛАСС СПИСОК

class List
{
public:
	Node* Head, * Tail;                  //Указатели на начало списка и на конец
public:
	List() :Head(nullptr), Tail(nullptr) {};    //Инициализация указателей как пустых
	~List();                           //Деструктор для освобождения памяти от всего что будет
	void Add(float x);                   //Функция заполнения структуры Node и добавления её в список как элемента
	void Show();                       //Функция отображения списка List
	void del();                        //Функция изъятия элемента

};

List::~List() //ДЕСТРУКТОР ДЛЯ ОЧИСТКИ ПАМЯТИ
{
	Node* temp = Head;                     //Временный указатель на начало списка
	while (temp != nullptr)                   //Пока в списке что-то есть

	{
		temp = Head->Next;                 //Резерв адреса на следующий элемент списка

		delete Head;                       //Освобождение памяти от первой структуры как элемента списка

		Head = temp;                       //Сдвиг начала на следующий адрес, который берем из резерва

	}
}

//ФУНКЦИЯ ЗАПОЛНЕНИЯ ИНФОРМАЦИОННЫХ ПОЛЕЙ СТРУКТУРЫ NODE И ДОБАВЛЕНИЯ ЭТОЙ СТРУКТУРЫ В СПИСОК
void List::Add(float x)
{
	Node* temp = new Node;              //Выделение памяти для нового звена списка
	temp->x = x;                        //Временное запоминание принятого параметра x
	temp->Next = nullptr;                  //Указание, что следующее звено новосозданной структуры пока пустое

	if (Head != nullptr)                   //Если список не пуст
	{
		Tail->Next = temp;              //Указание, что следующее звено списка это новосозданная структура
		Tail = temp;
	}
	else
		Head = Tail = temp;      //Если список не пуст, добавление первого элемента
}

//ФУНКЦИЯ ОТОБРАЖЕНИЯ СПИСКА НА ЭКРАНЕ
void List::Show()
{
	Node* temp = Head;                  //Временный указатель на начало списка
	while (temp != nullptr)               //Пока в списке что-то встречается
	{
		cout << temp->x << " ";        //Выводим значения из списка на экран
		temp = temp->Next;             //Сдвигаем указатель на начало на адрес следующего элемента
	}
	cout << endl;
}

//ФУНКЦИЯ ИЗЪЯТИЯ ЭЛЕМЕНТА ИЗ ОЧЕРЕДИ
void List::del()
{
	if (Head != nullptr)                   //Если список не пустой
	{
		Node* temp = Head;              //Обращаемся к началу списка с помощью вспомогательного указателя
		cout << "ЭЛЕМЕНТ " << Head->x << " ВЫШЕЛ" << endl;
		Head = Head->Next;              //Сдвиг начала списка
		delete temp;                    //Освобождение памяти от предыдущего звена списка
	}
}
void MidleLevel()
{
	/*
	Создать очередь вещественных значений, для реализации используя односвязные списки. 
	Реализовать операции добавления (enqueue) и удаления (dequeue) элемента из очереди. Добавьте в очередь
	числа: -2.2, 2.3, 2.2, 5.1, 6.7 и распечатайте содержимое очереди. Удалите 3 элемента из очереди, затем
	добавьте в очередь число 1.9 и распечатайте очередь еще раз.  Найдите произведение элементов, 
	принадлежащих очереди. 
	*/
	cout << "\nMdle level task\n";
	List lst;
	system("CLS");
	float a;
	cout << "Заполните очередь следцщими элементами: -2.2, 2.3, 2.2, 5.1, 6.7\n";
	for (int i = 0; i < 5; i++) {
		printf("\nВведите элемент очереди %d: ", i + 1);
		scanf("%f", &a);
		lst.Add(a);
	}
	lst.Show();
	for (size_t i = 0; i < 3; i++)
	{
		lst.del();

	}
	cout << endl;
	lst.Show();
	cout << "\nВ очередь добавлен элемент $ 1.9\n";
	lst.Add(1.9);
	lst.Show();
	Node* temp = lst.Head;
	float composition = 1;
	while (temp != nullptr)                   //Пока в списке что-то есть
	{
		composition *= temp->x;
		temp = temp->Next;                 //Резерв адреса на следующий элемент списка
			//Сдвиг начала на следующий адрес, который берем из резерва
	}
	cout << "\nПроизвидение элементов очереди " << composition;
		
	getchar(); 
	getchar();
	
}

void HardLevel()
{
	/*
Арифметическое выражение можно представить в обратной польской записи, где знаки операции следуют за 
операндами (а не ставятся между ними, как в обычной записи выражений). Обратная польская запись не требует 
скобок. Например, выражению «1 + 2» соответствует запись «1 2 +», выражению «1 + 2 * 3» запись «1 2 3 * +» 
(вначале умножаются 2 на 3, а потом 1 складывается с результатом), «(2 + 3) * (3 – 1)» записывается как
«2 3 + 3 1 – *». Задается строка – выражение в обратной польской записи (числа и знаки +, –, * разделены 
пробелами). Используя стек, вычислите значение выражения. Подсказка: нужно последовательно перебрать все
числа и знаки из строки, числа нужно заносить в стек, а как встретится знак операции, вынимать 2 числа из 
стека, применять к ним текущую операцию, а результат заносить в стек.
	*/


}
void main()
{
	SetConsoleOutputCP(1251);
	SetConsoleCP(1251);
	setlocale(0, "");
	srand(time(0));
	//BaseLevel();
	//MidleLevel();
	HardLevel();

}

